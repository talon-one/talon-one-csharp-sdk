// <auto-generated>
/*
 * Talon.One API
 *
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 
 *
 * Contact: devs@talon.one
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TalonOneSdk.Client;

namespace TalonOneSdk.Model
{
    /// <summary>
    /// NewPriceAdjustment
    /// </summary>
    public partial class NewPriceAdjustment : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NewPriceAdjustment" /> class.
        /// </summary>
        /// <param name="priceType">The price type (e.g. the price for members only) to apply to a given SKU.</param>
        /// <param name="referenceId">A unique reference identifier, e.g. a UUID.</param>
        /// <param name="price">The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU.</param>
        /// <param name="calculatedAt">The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.</param>
        /// <param name="effectiveFrom">The date and time from which the price adjustment is effective.</param>
        /// <param name="effectiveUntil">The date and time until which the price adjustment is effective.</param>
        /// <param name="contextId">Identifier of the context of this price adjustment (e.g. summer sale).</param>
        [JsonConstructor]
        public NewPriceAdjustment(string priceType, string referenceId, Option<decimal?> price = default, Option<DateTime?> calculatedAt = default, Option<DateTime?> effectiveFrom = default, Option<DateTime?> effectiveUntil = default, Option<string> contextId = default)
        {
            PriceType = priceType;
            ReferenceId = referenceId;
            PriceOption = price;
            CalculatedAtOption = calculatedAt;
            EffectiveFromOption = effectiveFrom;
            EffectiveUntilOption = effectiveUntil;
            ContextIdOption = contextId;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The price type (e.g. the price for members only) to apply to a given SKU.
        /// </summary>
        /// <value>The price type (e.g. the price for members only) to apply to a given SKU.</value>
        /* <example>member</example> */
        [JsonPropertyName("priceType")]
        public string PriceType { get; set; }

        /// <summary>
        /// A unique reference identifier, e.g. a UUID.
        /// </summary>
        /// <value>A unique reference identifier, e.g. a UUID.</value>
        /* <example>68851723-e6fa-488f-ace9-112581e6c19b</example> */
        [JsonPropertyName("referenceId")]
        public string ReferenceId { get; set; }

        /// <summary>
        /// Used to track the state of Price
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<decimal?> PriceOption { get; private set; }

        /// <summary>
        /// The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU.
        /// </summary>
        /// <value>The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU.</value>
        /* <example>100</example> */
        [JsonPropertyName("price")]
        public decimal? Price { get { return this.PriceOption; } set { this.PriceOption = new Option<decimal?>(value); } }

        /// <summary>
        /// Used to track the state of CalculatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CalculatedAtOption { get; private set; }

        /// <summary>
        /// The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.
        /// </summary>
        /// <value>The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.</value>
        /* <example>2021-09-12T10:12:42Z</example> */
        [JsonPropertyName("calculatedAt")]
        public DateTime? CalculatedAt { get { return this.CalculatedAtOption; } set { this.CalculatedAtOption = new Option<DateTime?>(value); } }

        /// <summary>
        /// Used to track the state of EffectiveFrom
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> EffectiveFromOption { get; private set; }

        /// <summary>
        /// The date and time from which the price adjustment is effective.
        /// </summary>
        /// <value>The date and time from which the price adjustment is effective.</value>
        /* <example>2021-09-12T10:12:42Z</example> */
        [JsonPropertyName("effectiveFrom")]
        public DateTime? EffectiveFrom { get { return this.EffectiveFromOption; } set { this.EffectiveFromOption = new Option<DateTime?>(value); } }

        /// <summary>
        /// Used to track the state of EffectiveUntil
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> EffectiveUntilOption { get; private set; }

        /// <summary>
        /// The date and time until which the price adjustment is effective.
        /// </summary>
        /// <value>The date and time until which the price adjustment is effective.</value>
        /* <example>2021-09-12T10:12:42Z</example> */
        [JsonPropertyName("effectiveUntil")]
        public DateTime? EffectiveUntil { get { return this.EffectiveUntilOption; } set { this.EffectiveUntilOption = new Option<DateTime?>(value); } }

        /// <summary>
        /// Used to track the state of ContextId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> ContextIdOption { get; private set; }

        /// <summary>
        /// Identifier of the context of this price adjustment (e.g. summer sale).
        /// </summary>
        /// <value>Identifier of the context of this price adjustment (e.g. summer sale).</value>
        /* <example>Summer2025</example> */
        [JsonPropertyName("contextId")]
        public string ContextId { get { return this.ContextIdOption; } set { this.ContextIdOption = new Option<string>(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class NewPriceAdjustment {\n");
            sb.Append("  PriceType: ").Append(PriceType).Append("\n");
            sb.Append("  ReferenceId: ").Append(ReferenceId).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  CalculatedAt: ").Append(CalculatedAt).Append("\n");
            sb.Append("  EffectiveFrom: ").Append(EffectiveFrom).Append("\n");
            sb.Append("  EffectiveUntil: ").Append(EffectiveUntil).Append("\n");
            sb.Append("  ContextId: ").Append(ContextId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // ReferenceId (string) minLength
            if (this.ReferenceId != null && this.ReferenceId.Length < 1)
            {
                yield return new ValidationResult("Invalid value for ReferenceId, length must be greater than 1.", new [] { "ReferenceId" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="NewPriceAdjustment" />
    /// </summary>
    public class NewPriceAdjustmentJsonConverter : JsonConverter<NewPriceAdjustment>
    {
        /// <summary>
        /// The format to use to serialize CalculatedAt
        /// </summary>
        public static string CalculatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize EffectiveFrom
        /// </summary>
        public static string EffectiveFromFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize EffectiveUntil
        /// </summary>
        public static string EffectiveUntilFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="NewPriceAdjustment" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override NewPriceAdjustment Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string> priceType = default;
            Option<string> referenceId = default;
            Option<decimal?> price = default;
            Option<DateTime?> calculatedAt = default;
            Option<DateTime?> effectiveFrom = default;
            Option<DateTime?> effectiveUntil = default;
            Option<string> contextId = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "priceType":
                            priceType = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "referenceId":
                            referenceId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "price":
                            price = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "calculatedAt":
                            calculatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "effectiveFrom":
                            effectiveFrom = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "effectiveUntil":
                            effectiveUntil = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "contextId":
                            contextId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!priceType.IsSet)
                throw new ArgumentException("Property is required for class NewPriceAdjustment.", nameof(priceType));

            if (!referenceId.IsSet)
                throw new ArgumentException("Property is required for class NewPriceAdjustment.", nameof(referenceId));

            if (priceType.IsSet && priceType.Value == null)
                throw new ArgumentNullException(nameof(priceType), "Property is not nullable for class NewPriceAdjustment.");

            if (referenceId.IsSet && referenceId.Value == null)
                throw new ArgumentNullException(nameof(referenceId), "Property is not nullable for class NewPriceAdjustment.");

            if (calculatedAt.IsSet && calculatedAt.Value == null)
                throw new ArgumentNullException(nameof(calculatedAt), "Property is not nullable for class NewPriceAdjustment.");

            if (effectiveFrom.IsSet && effectiveFrom.Value == null)
                throw new ArgumentNullException(nameof(effectiveFrom), "Property is not nullable for class NewPriceAdjustment.");

            if (effectiveUntil.IsSet && effectiveUntil.Value == null)
                throw new ArgumentNullException(nameof(effectiveUntil), "Property is not nullable for class NewPriceAdjustment.");

            if (contextId.IsSet && contextId.Value == null)
                throw new ArgumentNullException(nameof(contextId), "Property is not nullable for class NewPriceAdjustment.");

            return new NewPriceAdjustment(priceType.Value, referenceId.Value, price, calculatedAt, effectiveFrom, effectiveUntil, contextId);
        }

        /// <summary>
        /// Serializes a <see cref="NewPriceAdjustment" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="newPriceAdjustment"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, NewPriceAdjustment newPriceAdjustment, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, newPriceAdjustment, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="NewPriceAdjustment" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="newPriceAdjustment"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, NewPriceAdjustment newPriceAdjustment, JsonSerializerOptions jsonSerializerOptions)
        {
            if (newPriceAdjustment.PriceType == null)
                throw new ArgumentNullException(nameof(newPriceAdjustment.PriceType), "Property is required for class NewPriceAdjustment.");

            if (newPriceAdjustment.ReferenceId == null)
                throw new ArgumentNullException(nameof(newPriceAdjustment.ReferenceId), "Property is required for class NewPriceAdjustment.");

            if (newPriceAdjustment.ContextIdOption.IsSet && newPriceAdjustment.ContextId == null)
                throw new ArgumentNullException(nameof(newPriceAdjustment.ContextId), "Property is required for class NewPriceAdjustment.");

            writer.WriteString("priceType", newPriceAdjustment.PriceType);

            writer.WriteString("referenceId", newPriceAdjustment.ReferenceId);

            if (newPriceAdjustment.PriceOption.IsSet)
                if (newPriceAdjustment.PriceOption.Value != null)
                    writer.WriteNumber("price", newPriceAdjustment.PriceOption.Value.Value);
                else
                    writer.WriteNull("price");

            if (newPriceAdjustment.CalculatedAtOption.IsSet)
                writer.WriteString("calculatedAt", newPriceAdjustment.CalculatedAtOption.Value.Value.ToString(CalculatedAtFormat));

            if (newPriceAdjustment.EffectiveFromOption.IsSet)
                writer.WriteString("effectiveFrom", newPriceAdjustment.EffectiveFromOption.Value.Value.ToString(EffectiveFromFormat));

            if (newPriceAdjustment.EffectiveUntilOption.IsSet)
                writer.WriteString("effectiveUntil", newPriceAdjustment.EffectiveUntilOption.Value.Value.ToString(EffectiveUntilFormat));

            if (newPriceAdjustment.ContextIdOption.IsSet)
                writer.WriteString("contextId", newPriceAdjustment.ContextId);
        }
    }
}
